---
author: Kolyn090
banner: /static/img/svz/player-hp-banner.png
categories: Tutorial
custom_class: custom-page-content
date: 2025-02-10 14:00:00 -0500
layout: post
permalink: /svz-player-hp/
theme: sushi
title: Reading player HP from static health bar
---


**This article, completely original, is copyrighted by its author, me. Please do not reproduce it.**


**æœ¬æ–‡ä¸ºåŸåˆ›ä½œå“ï¼Œä½œè€… Kolyn090 æ‹¥æœ‰å…¶è‘—ä½œæƒï¼Œå—æ³•å¾‹ä¿æŠ¤ã€‚ä¸¥ç¦å¤åˆ¶ã€è½¬è½½ã€ä»¿å†’æˆ–ä»¥ä»»ä½•å½¢å¼ä½¿ç”¨ã€‚**


Category: Tutorial


Platform: Windows


Prerequisite: Basic Python, read [this article](/svz-pachinko/)


## Introduction
This is the very first thing we are going to do for a [big plan](/svz-battle/)! Today we will be reading the player's health point from a health bar using Computer Graphics techniques. You should be able to apply what you will be learning to most of the basic health bars. 

Before we get into the tutorial, we need to understand what exactly is a health bar to us. 
1. It represents the health point of something (e.g. Your character) and it usually consists of a filling area and a background. 
2. Larger the filling area means more health. The filling area and the background usually have different colors. 
3. Sometime a numerical representation is shown next to the health bar, and it would be much easier to read that instead (but unfortunately we don't have that in this case).
4. The color of the filling area and background could be complex! Luckily in this case it's simple. If you are working with some very interest cases you will have to do some additional tricks / use [Cheat Engine](https://cheatengine.org/) to read the value.


## The general idea
As usual, let's plan out the approach step by step. Assuming you have the screenshot from the game.


1 . **Crop out the health bar.** 


2 . **Select pivot rows.**


3 . **Color quantization.**


4 . **Calculate background area.**


5 . **Remaining HP = 1 - (background area / total area).**

---

<u>The first step is perhaps the most important one among them!</u> You might not even get a result if you don't do this correctly. Make sure you include only the necessary part. Otherwise you will run into problems in color quantization (color reduction). If the hp bar is static, you can predefine a bound for hp bar. If it's moving, the difficulty will exponentially increase! Fortunately in our case it's static. 

---

The second step is optimization. I hope you can agree with me that there is no need to process the entire hp bar. Here is what I mean:


![hp_bar_example](/static/img/svz/hp_bar_example.png)


You can see that it's good enough to just take the central rows, like shown in the image. We will get a very close result as well by processing this smaller region. In fact, we can even combine step 1 and step 2 together but I won't do that so that you could get a better idea.

---

The third step is color quantization. It's a fancy word saying reducing the number of colors in the image. Visually, it's like:


![hp_bar_example2](/static/img/svz/hp_bar_example2.png)


![hp_bar_example3](/static/img/svz/hp_bar_example3.png)


Here the quantization algorithm has reduced 97 colors (top) to 3 colors (bottom). We do this to reduce noises in the image. In our case, we want to reduce to 2 ~ 3 colors so that we the filling area and the background can be easily distinguished.

---

Now comes the fourth step. You might be wondering why we choose to calculate the background color area instead of the filling area. Well, by observing our hp bar we find out that the color of our filling area is changing (green - yellow - red) while the background color is always gray. That gives a good reason why we choose that over the other. In the fifth step, we will use this area to divide by the area of the hp bar image to get the ratio of background, which is the ratio of **lost HP**. To get the remaining HP, it's just 1 - lost HP. 


# Step 1
Again, I really assumed you have read and followed the [pachinko series](/svz-pachinko/) I wrote. It's going to be very hard to follow the rest if you don't. 


Since we are going to build an entire AI model and this is the first step, I will start a new folder `ai`. Inside that, create a new folder `player_hp` and a python script `ui_position.py`. Inside `player_hp`, create a new folder `debug` and a new python script `player_hp.py`.


{% highlight cmd %}
ai
|__ player_hp
|   |__ debug
|   |__ player_hp.py
|__ ui_position.py
{% endhighlight %}

---

ğŸ“ Before we actually add new things, let's fix a problem came from my side. I must admit that I didn't know that the Ads in BlueStacks can be hidden! Yes, they can be hidden! Go ahead and read a section called "Solving the first issue" in [this article](/proportional-mouse-pointer/). There is no need to read anything else. After you have done that you will not longer see the Ads. **Please make sure you hide the Ads because the rest of the series will be based on the version without Ads.**

---

In `window_rescaler.py`, change this line
{% highlight python %}
top, left, bottom, right = 0, -164, 482, 819
{% endhighlight %}
to
{% highlight python %}
top, left, bottom, right = 0, 0, 482, 819
{% endhighlight %}
ğŸ¤“ Since we have hidden the Ads widget, we need to add that back to left.

---

Inside `ui_position.py`, put
{% highlight python %}
player_hp_bound = [434, 62, 529, 75]
{% endhighlight %}
ğŸ¤“ As said before, it is important to make sure that this is your actual player hp bound. Next we will be verifying you have gotten the correct bound.

---

Let's write two new functions in `screen_getter.py`.
{% highlight python %}
import cv2
import numpy as np

def get_chosen_region(window, region) -> Image.Image:
    def run_win():
        x = window.left + region[0]
        y = window.top + region[1]
        w = region[2] - region[0]
        h = region[3] - region[1]

        return ImageGrab.grab(bbox=(x, y, x + w, y + h))

    if platform.system() == 'Windows':  # Better way to check OS
        return run_win()
    return None

def get_chosen_region_cv2(window, region) -> np.ndarray:
    def run_win():
        img = get_chosen_region(window, region)
        img_cv = np.array(img)

        return cv2.cvtColor(img_cv, cv2.COLOR_RGB2BGR)

    if platform.system() == 'Windows':
        return run_win()
    return None
{% endhighlight %}

ğŸ¤“ `get_chosen_region()` directly crops out the chosen bound and returns a `PIL` image. This is more efficient than what we were doing before: take the entire screenshot and crop that. The `get_chosen_region()` variant outputs a `cv2` image.

---
Now, inside `player_hp.py`, add the following
{% highlight python %}
import time
import numpy as np
from PIL import Image
from src.program.program_obj import Program_Obj
from src.util.screen_getter import get_window_with_title, get_chosen_region
from src.ai.ui_position import player_hp_bound


class Player_HP:
    def __init__(self, window, pivot_count=1, bg_value=38):
        self._window = window
        self._pivot_count = pivot_count
        self._bg_value = bg_value  # Background value: [38, 38, 38]
        self.debug = False
{% endhighlight %}
ğŸ¤“ Like many UI-related classes from before, it includes a window. The pivot count is for step 2. The bg (background) value is for step 4. I have already explained the high-level idea in the general idea section so I won't explain them again. In the end, we have `debug` flag.


Now, in `Player_HP`, add this function
{% highlight python %}
def get_percentage(self):
    # Step 1
    hp_bar = get_chosen_region(self._window, player_hp_bound)

    if self.debug:
        hp_bar.save('debug/hp_bar.png')

    return 0
{% endhighlight %}


Also add the driver code in the same script.
{% highlight python %}
if __name__ == '__main__':
    Program_Obj()
    chosen_window = get_window_with_title('BlueStacks App Player')
    player_hp = Player_HP(chosen_window)
    player_hp.debug = True

    while True:
        print(player_hp.get_percentage())
        time.sleep(0.5)
{% endhighlight %}
ğŸ¤“ Enter battle mode and run the code. You should see zeroes being printed. The important thing to check is `hp_bar.png` under the `debug` folder. Make sure you have something similar to this.


![hp_bar](/static/img/svz/hp_bar.png)


<br>
ğŸ‰ If you did, congratulations! You have done step 1. I hope it wasn't too bad.


# Step 2
In this step we are cropping out the pivot rows from the hp bar image. Add this function to `Player_HP` class.
{% highlight python %}
def _get_pivot_part(self, hp_bar: Image.Image) -> Image.Image:
    width, height = hp_bar.size

    # calculate cropping box for center pivot rows
    top = (height - self._pivot_count) // 2
    bottom = top + self._pivot_count
    left = 0
    right = width

    return hp_bar.crop((left, top, right, bottom))
{% endhighlight %}
ğŸ¤“ This simply used the `crop()` function in `PIL` library to get the centre rows that we are interested in. The new image's height is equal to the pivot count. Visually, it's like (not up to scale)


![hp_bar_example4](/static/img/svz/hp_bar_example4.png)


We can add new stuff to `get_percentage()` now. Modify it like so
{% highlight python %}
def get_percentage(self):
    # Step 1
    hp_bar = get_chosen_region(self._window, player_hp_bound)
    # Step 2
    pivot_part = self._get_pivot_part(hp_bar)

    if self.debug:
        hp_bar.save('debug/hp_bar.png')
        pivot_part.save('debug/pivot_part.png')

    return 0
{% endhighlight %}


Run the driver code and check `debug`. You should be expecting a new image `pivot_part.png`. Its dimension is something like 95x1 so it might be very hard to see here â¬‡ï¸


![pivot_part](/static/img/svz/pivot_part.png)


ğŸ‰ That's all for step 2!


# Step 3
